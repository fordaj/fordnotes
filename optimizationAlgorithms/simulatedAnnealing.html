<!DOCTYPE html>
<html>
    <head>
        <title>Simulated Annealing</title>
        <link rel="stylesheet" href="../style.css" />
        <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500&family=Roboto:wght@100;400;500&display=swap" rel="stylesheet">
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
    </head>
    <body>
		<h1><a target="_self" href="https://www.fordnotes.org">Notebook</a></h1>
		<h2>Optimization Algorithms</h2>
		<h3>Simulated Annealing</h3>
        <p>
            This is a heuristic, non-greedy, probalistic optimization algorithm,
            that when properly tuned, works incredibly well.
            <b>Annealing</b> refers to the process of heating and then slowly
            cooling glass or metal to minimize internal stress, while
            strengthening the material. This process is simulated
            programmatically, and tuned to optimize a dataset through random
            'moves'. As with most algorithms, it is best used when exhaustive
            testing is not feasible, typically due to processing time. It can be
            used to optimize anything that has static placement
            post-optimization. For instance, an algorithm controlled by a
            handful of paremeters can be tuned by simulated annealing. Wiring
            placement and routing can be optimized as well.
        </p>
        <h4>Algorithm</h4>
        <p>
            Below is the pseudo-code for simulated annealing. The tuneable
            parameters are first, and should be altered until the algorithm
            produces ideal results. In this case, we will be tuning SA in python
            to optimize a Cryptocurrency trading algorithm. The trading
            algorithm is trained using the price of ethereum from 2017-2020 with
            the goal of accruing the largest profits.
        </p>
        <code>temperature = 40000
freezing = 0.1
moves = 250
cooling = 0.95
boltzmann = 1e-3
currentSolution = initialSolution

while (temperature > freezing):
    for i in range(0,moves):
    nextSolution = perturb(currentSolution)
    delCost = cost(nextSolution) - cost(currentSolution)
    if (delCost < 0 or e^(-delCost/(boltzmann/temperature)) > rand(0,1)):
        currentSolution = nextSolution
    temperature *= cooling</code>
    </body>
</html>
